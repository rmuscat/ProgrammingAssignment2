## Put comments here that give an overall description of what your
## functions do
# makeCacheMatrix 
#     creates a special type of matrix whose Inverse is cachable from a normal matrix
# cacheSolve() 
#     generates the inverse of a matrix (generated by makeCacheMatrix) and solves it in a CacheMatrix.
#     The inverse is cached and hence does not get generated everytime.

#################################
# EXAMPLE USAGE
# > m <- replicate(3,rnorm(3))
# > cm <- makeCacheMatrix(m)
# > cacheSolve(cm) %*% cm$get()
# > round(cacheSolve(cm) %*% cm$get())
# Retrieving cached inverse...
# [,1] [,2] [,3]
# [1,]    1    0    0
# [2,]    0    1    0
# [3,]    0    0    1

# This is a function which generates  CacheMatrix object given a Matrix object
# The object stores the original matrix and it's inverse
# set / get will allow to you access/set the matrix
# setInverse / getInverse will allow to you access/set the inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
  mInverse <- NULL # Initialise the inverse to nothing
  
  set <- function(y) {
    # set x in the global variable
    x <<- y
    mInverse <- NULL # Initialise the inverse to nothing
  }
  
  get <- function() {
    x
  }
  
  setInverse <- function(inverse) {
    # set mInverse in the global variable
    mInverse <<- inverse # set the internal object inverse to the parameter
  } 
  
  getInverse <- function() {
    mInverse
  }
  list (set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}


## This function determines if the inverse of a CacheMatrix exists before computing it
## If it exists it will just return it
## If it DOES NOT, it will compute it, save it in CacheMatrix and return it
cacheSolve <- function(x, ...) {
    ## Return a matrix that is the inverse of 'x'
    localInverse <- x$getInverse() # Right, pull the inverse from the CacheMatrix object
    if (!is.null(localInverse)) { # is it set yet?
      message("Retrieving cached inverse...")
      return(localInverse) # success! Zero Effort. Return it and exit
    }
    localMatrix <- x$get() # Oh no it's not there, lets get the original matrix then
    localInverse <- solve(localMatrix,...) # Compute the Inverse
    x$setInverse(localInverse) # use the setInverse to save it in CacheMatrix for next time
    localInverse
}
